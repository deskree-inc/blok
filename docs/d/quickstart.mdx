---
title: Creating API Service
---

In this short guide we will showcase how to instantiate the nanoservice-ts framework and run a simple workflow. 

In this example we will create an API that will get the list of all space launches that happened in the year a person was born. The API will accept one parameter `dob: string` as date of birth and return a `json` list of space launches.

---

# Initialilizing
<Tip> The `nanoctl` package for nanoservice-ts is a command-line tool designed to simplify the creation and setup of nanoservice projects. It enables developers to quickly initialize ready-to-use project structures with minimal configuration. To learn more about available commands, visit [nanoctl](/docs/d/core-concepts/nanoctl) </Tip>

To initialize the project, simply run the following command and follow the instructions of the interactive setup:

<Steps>
  <Step title="Run the command">
  ```bash
  npx nanoctl@latest create project
  ```
  </Step>
  <Step title="Follow the interactive prompts">
   ```plaintext
    Select a template: HTTP API
    Project Name: my-api-project
    Install dependencies and start coding:
   ```
  </Step>
  <Step title="Install dependencies and start coding">
   ```bash
    cd my-api-project
    npm install
    npm run dev
    ```
  </Step>
</Steps>
After creating a project using the npx package, your folder might look like this:

```plaintext
my-api-project/
├── package.json
├── workflows/
│   └── example-workflow.json
├── nodes/
└── src/
    └── index.ts
```
Key Directories:
* `workflows/`: Contains your nanoservice workflow definitions.
* `nodes/`: Contains custom nodes that extend functionality.
* `src/`: Your project’s main logic and entry point.

---

# Creating nodes
<Tip> **Node** is designed to perform a specific, reusable task within a workflow. To learn more, visit [nodes](/docs/d/core-concepts/nodes) </Tip>

For this project, we will create 2 custom nodes:
* `api-call` - a node for fetching data from an external API.
* `get-year` - a node for extracting the year from a date of birth.

### Setup

To create your first node, run the following command:

<Steps>
  <Step title="Run the command">
  ```bash
  npx nanoctl@latest create node
  ```
  </Step>
  <Step title="Follow the interactive prompts">
   ```plaintext
    Assign a name to the node: api-call
   ```
  </Step>
    <Step title="Install dependencies and start coding">
   ```bash
    cd nodes/api-call
    npm install
    ```
  </Step>
</Steps>
After running the command, a new directory was added to the `nodes/` folder under the new node's name with all the necessary files to start coding your custom node:

```plaintext
my-api-project/
├── package.json
├── workflows/
│   └── example-workflow.json
├── nodes/
│   └── api-call/
│    ├── test/
│    │   └── index.test.ts
│    ├── config.json
│    ├── index.ts
│    ├── nodemon.json
│    ├── package.json
│    ├── README.md
│    └── tsconfig.json
└── src/
    └── index.ts
```

Repeat the process for the second node with a name `get-year`. After running the `npx nanoctl@latest create node` and providing the `get-year` name, a new directory will be created in the `nodes/` folder with the same structure as the first node.

---

### Defining node logic
<Tip> The `index.ts` file is the main file for your custom node. It contains the logic that will be executed by the node during workflow invocation.</Tip>

In the `nodes/api-call/index.ts` we will create a node that will fetch data from an external API. For the simplicity of this example it will be hardcoded for only `GET` requests with headers set to `application/json`, will receive a URL as an input and return the response.

```typescript
import { type BlueprintContext, BlueprintError } from "@deskree/blueprint-shared";
import {
	type INanoServiceResponse,
	type JsonLikeObject,
	NanoService,
	NanoServiceResponse,
} from "@nanoservice-ts/runner";

// This is the main class that will be exported
// This class will be used to create a new instance of the node
// This class must be created using the extends NanoService
export default class Node extends NanoService {
	constructor() {
		super();

		// Set the input "JSON Schema Format" here for automated validation
		// Learn JSON Schema: https://json-schema.org/learn/getting-started-step-by-step
		this.inputSchema = {
      type: "string",
      title: "url",
    };

		// Set the output "JSON Schema Format" here for automated validation
		// Learn JSON Schema: https://json-schema.org/learn/getting-started-step-by-step
		this.outputSchema = {
      type: "object",
      title: "response",
    };
	}

	async handle(ctx: BlueprintContext, inputs: JsonLikeObject): Promise<INanoServiceResponse> {
		// Create a new instance of the response
		const response: NanoServiceResponse = new NanoServiceResponse();

		try {
			const data = await fetch(inputs.url, {method: "GET", headers: {"Content-Type": "application/json"}});
			response.setSuccess(data.data); // Set the success
		} catch (error: unknown) {
			const nodeError: BlueprintError = new BlueprintError((error as Error).message);
			nodeError.setCode(500);
			nodeError.setStack((error as Error).stack);
			nodeError.setName(this.name);
			nodeError.setJson(undefined); // Return a custom JSON object here

			response.setError(nodeError); // Set the error
		}

		return response;
	}
}
```

Now, let's create the second node `get-year` that will extract the year from the date of birth. In the `nodes/get-year/index.ts` file, implement the logic for your custom node. 


```typescript
import { type BlueprintContext, BlueprintError } from "@deskree/blueprint-shared";
import {
	type INanoServiceResponse,
	type JsonLikeObject,
	NanoService,
	NanoServiceResponse,
} from "@nanoservice-ts/runner";

// This is the main class that will be exported
// This class will be used to create a new instance of the node
// This class must be created using the extends NanoService
export default class Node extends NanoService {
	constructor() {
		super();

		// Set the input "JSON Schema Format" here for automated validation
		// Learn JSON Schema: https://json-schema.org/learn/getting-started-step-by-step
		this.inputSchema = {
      type: "string",
      title: "date",
    };

		// Set the output "JSON Schema Format" here for automated validation
		// Learn JSON Schema: https://json-schema.org/learn/getting-started-step-by-step
		this.outputSchema = {
      type: "integer",
      title: "year",
    };
	}

	async handle(ctx: BlueprintContext, inputs: JsonLikeObject): Promise<INanoServiceResponse> {
		// Create a new instance of the response
		const response: NanoServiceResponse = new NanoServiceResponse();

		try {
      const date = new Date(inputs.date);
      const year = date.getYear();
			response.setSuccess(yeara); // Set the success
		} catch (error: unknown) {
			const nodeError: BlueprintError = new BlueprintError((error as Error).message);
			nodeError.setCode(500);
			nodeError.setStack((error as Error).stack);
			nodeError.setName(this.name);
			nodeError.setJson(undefined); // Return a custom JSON object here

			response.setError(nodeError); // Set the error
		}

		return response;
	}
}
```

### Add node configuration (optional)
<Tip> The `config.json` file is used to define the expected inputs and outputs for your custom nodes. It provides a structured way to specify the input and output formats, required fields, and other data. </Tip>
<Info> Please note that the `config.json` file is optional as it is only used by the Deskree platform to connect nodes together. It will be used in the future for other purposes within the framework. Hence, we still recommend creating it as the best practice.</Info>

Let's set up `config.json` files for both of the nodes we've created. For the simplicity of this example, we will define only inputs and outputs, but you can learn more about the advanced configuration options in the [Node Configurations](https://nanoservice-ts.github.io/docs/).

For the `api-call` node, the `config.json` file should look like this:

```json
{
  "name": "api-call",
  "version": "1.0.0",
  "description": "",
  "group": "API",
  "config": {},
  "input": {
    "type": "string",
    "description": "The URL to fetch data from"
  },
  "output": {
    "type": "object",
    "description": "The response from the API call"
  },
  "steps": {
    "type": "boolean",
    "default": false
  },
  "functions": {
    "type": "array"
  }
}
```
For the `get-year` node, the `config.json` file should look like this:
```json
{
  "name": "get-year",
  "version": "1.0.0",
  "description": "",
  "group": "Utility",
  "config": {},
  "input": {
    "type": "string",
    "description": "The date to extract the year from"
  },
  "output": {
    "type": "integer",
    "description": "The year extracted from the date"
  },
  "steps": {
    "type": "boolean",
    "default": false
  },
  "functions": {
    "type": "array"
  }
}
```

### Registering nodes

Each node needs to be registered in the `src/Nodes.ts` file to be used in the workflow. To do this, import the node and register it in the `nodes` object. 

```typescript
import ApiCall from "../nodes/api-call";
import GetYear from "../nodes/get-year";
import type Nodes from "./types/Nodes";

const nodes: Nodes = {
    "@nanoservice-ts/api-call": new ApiCall(),
    "@nanoservice-ts/get-year": new GetYear(),
};

export default nodes;
```

Now the nodes can be used in the workflow.

# Creating a workflow
<Tip>**Workflow** is a JSON file that defines the sequence of tasks (nodes) to be executed. Think about it as a set of instructions to the run on how to put your nodes together. To learn more, visit [workflows](/docs/d/core-concepts/workflows.mdx)</Tip>

Now let's create a workflow that will use the nodes we've created. Create a new file in the `workflows` directory called `launches-by-year.json`.

```json
{
  "name": "launches-by-year",
  "trigger": {
    "http": {
      "method": "GET",
      "path": "/space"
    }
  },
  "steps": [
    {
      "name": "api",
      "node": "get-year",
      "inputs": {
        "date": "{{ctx.response.query.dob}}"
      }
    },
    {
      "name": "api",
      "node": "api-call",
      "inputs": {
        "url": "https://ll.thespacedevs.com/2.3.0/launches/?format=json&year={{get-year}}"
      }
    }
  ]
}
```

<Tip>**CTX** is a special object that contains the context of the workflow. It is used to pass data between nodes and steps. It is defined on the Trigger level. To learn more, visit [CTX](/docs/d/core-concepts/workflows#ctx)</Tip>

Note that in this example we are using `ctx` to get the original request query parameter `dob` and pass it to the `get-year` node. The `get-year` node will extract the year from the date of birth and pass it to the final response.

# Running & Testing
